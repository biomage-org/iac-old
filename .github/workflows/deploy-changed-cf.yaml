name: Deploy changed CloudFormation templates
on:
  workflow_dispatch:
    inputs:
      environment_name:
        type: choice
        description: Select the environment name to run the actions on
        options:
          - trv
          - Biomage
          - alabs
          - all
        default: all
      environment_type:
        type: choice
        description: Select environment type
        options:
          - staging
          - production
          - staging and production
        default: staging
  push:
    branches:
      - master
    paths:
      - 'cf/**.yaml'
      - 'cf/**.yml'
  pull_request:
    branches:
      - master
    paths:
      - 'cf/**.yaml'
      - 'cf/**.yml'

permissions:
    id-token: write
    contents: read

jobs:
  set-environments:
    name: Set up environment name and environment type for action run
    runs-on: ubuntu-20.04
    outputs:
        env-type: ${{ steps.set-env-type.outputs.env-type }}
        env-name: ${{ steps.set-env-name.outputs.env-name }}
    steps:
      - id: set-env-type
        name: Set up environment type
        run: |-
          if [ "${ENVIRONMENT_TYPE}" = "staging" ]; then
            echo 'env-type=["staging"]' >> $GITHUB_OUTPUT
          elif [ "${ENVIRONMENT_TYPE}" = "production" ]; then
            echo 'env-type=["production"]' >> $GITHUB_OUTPUT
          elif [ "${ENVIRONMENT_TYPE}" = "staging and production" ]; then
            echo 'env-type=["staging", "production"]' >> $GITHUB_OUTPUT
          fi
        env:
            ENVIRONMENT_TYPE: ${{ github.event.inputs.environment_type }}
      - id: set-env-name
        name: Set up environment name
        run: |-
          if [ "${ENVIRONMENT_NAME}" = "all" ]; then
            echo 'env-name=["Biomage", "trv", "alabs"]' >> $GITHUB_OUTPUT
          elif [ "${ENVIRONMENT_NAME}" = "trv" ]; then
            echo 'env-name=["trv"]' >> $GITHUB_OUTPUT
          elif [ "${ENVIRONMENT_NAME}" = "alabs" ]; then
            echo 'env-name=["alabs"]' >> $GITHUB_OUTPUT
          elif [ "${ENVIRONMENT_NAME}" = "Biomage" ]; then
            echo 'env-name=["Biomage"]' >> $GITHUB_OUTPUT
          fi
        env:
            ENVIRONMENT_NAME: ${{ github.event.inputs.environment_name }}

  check-secrets:
    name: Check secrets
    needs: set-environments
    runs-on: ubuntu-20.04
    if: github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        environment-type: ${{ fromJson(needs.set-environments.outputs.env-type) }}
        environment-name: ${{ fromJson(needs.set-environments.outputs.env-name) }}
        exclude:
            - environment-name: trv
              environment-type: staging
            - environment-name: alabs
              environment-type: staging
    environment: ${{ matrix.environment-name }}
    steps:
      - id: check-secrets
        name: Check if necessary secrets are installed.
        run: |-
          if [ -z "${{ secrets.AWS_ACCOUNT_ID }}" ]
          then
            echo "This workflow requires AWS_ACCOUNT_ID defined in this repository secrets to complete."
            echo "The secrets can be set/rotated by running 'rotate-ci' from 'biomage-utils'."
            ERROR=true
          fi
          if [ ! -z "$ERROR" ]
          then
            echo
            echo This workflow requires some secrets to complete.
            echo Please make they are created by adding/rotating them manually.
            exit 1
          fi

  get-modified-templates:
    name: Fetch paths to modified CloudFormation templates
    runs-on: ubuntu-20.04
    outputs:
      files: ${{ steps.check-number-of-cf-files.outputs.files }}
      num-files: ${{ steps.check-number-of-cf-files.outputs.num-files }}
    steps:
      - id: checkout
        name: Check out current branch source code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - id: validate-workflow-dispatch
        if: github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/master'
        name: Validate workflow dispatch
        run: |-
          echo Deploying the master branch via workflow_dispatch is not supported.
          echo To deploy master branch, raise a PR with changes to the CF files
          echo that needs to be deployed and merge the PR.
          exit 1

      - id: get-changed-files-on-pr-merge
        if: github.event_name == 'push' && github.ref == 'refs/heads/master'
        name: Get changed files on PR merge to master
        uses: lots0logs/gh-action-get-changed-files@2.1.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - id: get-changed-files-on-branch
        if: github.ref != 'refs/heads/master'
        name: Get changed files on branch
        run: |
          echo "[]" > empty.json

          # Get name of changed files
          CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT remotes/origin/master ${{ github.sha }})

          # If there are no changed files, create an empty array
          # else concatenate into an array
          if [ -z "$CHANGED_FILES" ]; then
            echo "[]" > ${HOME}/files.json
          else
            echo "$CHANGED_FILES" | xargs -I 'value' jq --arg filename "value" '. |= . + [$filename]' empty.json | jq -s 'add' > ${HOME}/files.json
          fi

          echo "All changed files"
          cat ${HOME}/files.json

      - id: check-number-of-cf-files
        name: Check CloudFormation templates
        run: |-
          # Select those that are CF templates (path starts with `cf/`)
          jq '[.[] | select(match("^cf/"))]' ${HOME}/files.json > ${HOME}/cf_files.json

          echo "Changed CF files"
          cat ${HOME}/cf_files.json

          # Set as output the minified JSON.
          echo "files=$(jq -c . < ${HOME}/cf_files.json)" >> $GITHUB_OUTPUT
          echo "$(jq -c . < ${HOME}/cf_files.json)"
          echo "num-files=$(jq '. | length' ${HOME}/cf_files.json)" >> $GITHUB_OUTPUT

  lint-templates:
    name: Lint template files
    runs-on: ubuntu-20.04
    needs: get-modified-templates
    if: needs.get-modified-templates.outputs.num-files > 0
    strategy:
      matrix:
        template: ${{fromJson(needs.get-modified-templates.outputs.files)}}
    steps:
      - id: checkout
        name: Check out source code
        uses: actions/checkout@v2

      - id: lint
        name: Lint template
        uses: scottbrenner/cfn-lint-action@v2.2.4
        with:
          args: ${{ matrix.template }}

  deploy-templates:
    name: Deploy changed CloudFormation template
    runs-on: ubuntu-20.04
    needs: [set-environments, check-secrets, get-modified-templates, lint-templates]
    if: github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    outputs:
      deploy-rds: ${{ steps.set-name.outputs.deploy-rds }}
    strategy:
      max-parallel: 1
      matrix:
        environment-type: ${{ fromJson(needs.set-environments.outputs.env-type) }}
        environment-name: ${{ fromJson(needs.set-environments.outputs.env-name) }}
        exclude:
          - environment-name: trv
            environment-type: staging
          - environment-name: alabs
            environment-type: staging
        template: ${{fromJson(needs.get-modified-templates.outputs.files)}}
    environment: ${{ matrix.environment-name }}
    env:
      CLUSTER_ENV: ${{ matrix.environment-type }}
    steps:
      - id: checkout
        name: Check out source code
        uses: actions/checkout@v2

      - id: set-up-creds
        name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ci-iac-role
          aws-region: ${{ secrets.AWS_REGION }}

      - id: set-name
        name: Set name of the CloudFormation stack
        run: |-
          echo "Ref is $GITHUB_REF"
          BASE_NAME=$(basename $FILE_NAME | sed "s/\..*//")
          STACK_NAME=biomage-$BASE_NAME-$CLUSTER_ENV

          echo "stack-name=$STACK_NAME" >> $GITHUB_OUTPUT

          if [ "$BASE_NAME" == 'rds' ]; then
            echo "deploy-rds=true" >> $GITHUB_OUTPUT
          fi

        env:
          FILE_NAME: ${{ matrix.template }}

      - id: using-self-signed-certificate
        name: Get config for whether deployment is using self-signed certificate
        uses: mikefarah/yq@master
        with:
          cmd: yq '.[env(ENVIRONMENT_NAME)].selfSignedCertificate' 'infra/config/github-environments-config.yaml'
        env:
          ENVIRONMENT_NAME: ${{ matrix.environment-name }}

      - id: deploy-template
        name: Deploy CloudFormation template
        if: ${{ !contains(matrix.template, 'irsa-') && matrix.template != 'cf/sns.yaml' && matrix.template != 'cf/ses.yaml' }}
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          parameter-overrides: "Environment=${{ matrix.environment-type }}"
          name: ${{ steps.set-name.outputs.stack-name }}
          template: ${{ matrix.template }}
          no-fail-on-empty-changeset: "1"
          capabilities: "CAPABILITY_IAM,CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"

      - id: deploy-sns-template
        name: Deploy CloudFormation SNS template
        if: ${{ matrix.template == 'cf/sns.yaml' }}
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          parameter-overrides: "Environment=${{ matrix.environment-type }},UsingSelfSignedCert=${{ steps.using-self-signed-certificate.outputs.result }}"
          name: ${{ steps.set-name.outputs.stack-name }}
          template: ${{ matrix.template }}
          no-fail-on-empty-changeset: "1"
          capabilities: "CAPABILITY_IAM,CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"

      - id: deploy-ses-template
        name: Deploy CloudFormation SES template
        if: ${{ matrix.template == 'cf/ses.yaml' }}
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
         parameter-overrides: "Environment=${{ matrix.environment-type }},DomainName=${{ secrets.DOMAIN_NAME }},PrimaryDomainName=${{ secrets.PRIMARY_DOMAIN_NAME }}"
         name: ${{ steps.set-name.outputs.stack-name }}
         template: ${{ matrix.template }}
         no-fail-on-empty-changeset: "1"

      # The following steps are only necessary for IAM Service Account roles.
      - id: get-oidc
        if: ${{ contains(matrix.template, 'irsa-') }}
        name: Get OIDC provider information for IRSA role
        run: |-
          OIDC_PROVIDER=$(aws eks describe-cluster --name "biomage-$CLUSTER_ENV" --query "cluster.identity.oidc.issuer" --output text | sed -e "s/^https:\/\///")
          echo "oidc-provider=$OIDC_PROVIDER" >> $GITHUB_OUTPUT

      - id: deploy-irsa-template
        if: ${{ contains(matrix.template, 'irsa-') }}
        name: Deploy IRSA CloudFormation template
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          parameter-overrides: "Environment=${{ matrix.environment-type }},OIDCProvider=${{ steps.get-oidc.outputs.oidc-provider }}"
          name: ${{ steps.set-name.outputs.stack-name }}
          template: ${{ matrix.template }}
          no-fail-on-empty-changeset: "1"
          capabilities: "CAPABILITY_IAM,CAPABILITY_NAMED_IAM"

  setup-rds-roles:
    name: Setup RDS roles for default resources
    runs-on: ubuntu-20.04
    needs: [set-environments, check-secrets, deploy-templates]
    strategy:
      max-parallel: 1
      matrix:
        environment-type: ${{ fromJson(needs.set-environments.outputs.env-type) }}
        environment-name: ${{ fromJson(needs.set-environments.outputs.env-name) }}
        exclude:
          - environment-name: trv
            environment-type: staging
          - environment-name: alabs
            environment-type: staging
    environment: ${{ matrix.environment-name }}
    env:
      CLUSTER_ENV: ${{ matrix.environment-type }}
    steps:
      - id: set-up-creds
        name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ci-iac-role
          aws-region: ${{ secrets.AWS_REGION }}

      # This step is needed to change the environment name (e.g. staging) into its uppercase form.
      # This is required because the action that is used in get-rds-secrets store the secret in environment variables,
      # with uppercase letters (see action ref). Therefore, we need the uppercased form of the environment
      # Which is output in .outputs.uppercase of this step.
      - id: setup-rds-env
        name: Uppercase environment name
        uses: ASzc/change-string-case-action@v2
        with:
          string: ${{ matrix.environment-type }}

      - id: get-rds-secrets
        name: Export RDS secrets into environment variables
        uses: abhilash1in/aws-secrets-manager-action@v2.0.0
        with:
          secrets: aurora-${{ matrix.environment-type }}
          parse-json: true

      - id: check-rds-secrets
        name: Check RDS secrets are fetched
        run: |-
          # These checks if the RDS username and passwords are set
          if [ -z $AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_USERNAME ]; then
            echo "RDS username not provided"
            exit 1
          fi
          if [ -z $AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_PASSWORD ]; then
            echo "RDS password not provided"
            exit 1
          fi

      - id: setup-rds-roles
        name: Setup RDS roles for default RDS instances
        run: |-
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=rds-${CLUSTER_ENV}-ssm-agent" \
            --output text \
            --query 'Reservations[*].Instances[*].InstanceId')
          if [ -z $INSTANCE_ID ]; then
            echo "Can not connect to RDS agent: No instances found for $CLUSTER_ENV"
            exit 1
          fi

          CLUSTER_NAME=aurora-cluster-${CLUSTER_ENV}-default

          RDSHOST=$(aws rds describe-db-cluster-endpoints \
            --region $REGION \
            --db-cluster-identifier $CLUSTER_NAME \
            --filter Name=db-cluster-endpoint-type,Values='writer' \
            --query 'DBClusterEndpoints[0].Endpoint' \
            --output text)
          if [ -z $RDSHOST ]; then
            echo "Failed getting RDS host with name $CLUSTER_NAME"
            exit 1
          fi

          ENSURE_PSQL_INSTALLED_COMMAND="sudo yum -y install postgresql"

          aws ssm send-command --instance-ids "$INSTANCE_ID" \
            --document-name AWS-RunShellScript \
            --parameters "commands='$ENSURE_PSQL_INSTALLED_COMMAND'"

          SETUP_ROLES_CMD="
            PGPASSWORD=\'${AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_PASSWORD}\' psql \
              --host=${RDSHOST} \
              --port=5432 \
              --username=${AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_USERNAME} \
              --dbname=aurora_db <<EOF
                CREATE ROLE api_role WITH LOGIN;
                CREATE ROLE dev_role WITH LOGIN;
                GRANT USAGE ON SCHEMA public TO api_role;
                GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public to api_role;
                GRANT dev_role TO ${AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_USERNAME};
                ALTER DEFAULT PRIVILEGES FOR USER dev_role IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO api_role;
                ALTER DEFAULT PRIVILEGES FOR USER dev_role IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO api_role;
                REVOKE dev_role FROM ${AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_USERNAME};
                GRANT rds_iam TO api_role;
                GRANT rds_iam, ${AURORA_${{ steps.setup-rds-env.outputs.uppercase }}_USERNAME} TO dev_role;
              EOF"

          aws ssm send-command --instance-ids "$INSTANCE_ID" \
            --document-name AWS-RunShellScript \
            --parameters "commands='$SETUP_ROLES_CMD'"
        env:
          REGION: ${{ secrets.AWS_REGION }}

  report-if-failed:
    name: Report if workflow failed
    runs-on: ubuntu-20.04
    needs: [set-environments, check-secrets, get-modified-templates, lint-templates, deploy-templates, setup-rds-roles]
    if: failure() && github.ref == 'refs/heads/master'
    steps:
      - id: send-to-slack
        name: Send failure notification to Slack on failure
        env:
          SLACK_BOT_TOKEN: ${{ secrets.WORKFLOW_STATUS_BOT_TOKEN }}
        uses: voxmedia/github-action-slack-notify-build@v1
        with:
          channel: workflow-failures
          status: FAILED
          color: danger